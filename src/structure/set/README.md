# Set

Set은 동일한 데이터를 중복해서 저장하지 않는, 순서가 없는 컬렉션입니다. 데이터의 순서가 중요하지 않고, 빠른 검색과 저장이 필요한 경우에 주로 사용됩니다. 예를 들어, 데이터의 중복을 제거하고 고유한 값만을
보유해야 하는 경우에 Set을 사용할 수 있습니다. Java에서는 Set 인터페이스를 구현한 다양한 클래스들이 제공되는데, 그중에서 가장 흔하게 사용되는 클래스들은 HashSet, LinkedHashSet,
TreeSet입니다.

### HashSet

HashSet은 Set 인터페이스를 구현한 클래스 중 가장 일반적으로 사용되는 클래스입니다. HashSet은 순서가 없는 컬렉션으로, 데이터를 해시 함수를 사용하여 저장합니다. HashSet은 데이터를 빠르게 추가,
삭제, 검색할 수 있어, 대량의 데이터를 처리할 때 효율적입니다. 하지만, 데이터의 **순서를 보장하지 않기** 때문에 순서에 따른 처리가 필요한 경우에는 다른 클래스를 선택해야 합니다.

### LinkedHashSet

LinkedHashSet은 HashSet의 확장된 형태로, 데이터의 **순서를 보장**하는 특징이 있습니다. 데이터가 추가된 순서대로 저장되기 때문에, 저장된 순서대로 데이터를 순회할 수 있습니다.
LinkedHashSet은 데이터의 순서가 중요한 경우에 사용될 수 있습니다. 하지만, HashSet보다는 약간의 성능 저하가 발생할 수 있습니다.

### TreeSet

TreeSet은 Set 인터페이스를 구현한 클래스 중 유일하게 데이터를 정렬된 상태로 저장하는 클래스입니다. TreeSet은 이진 검색 트리(binary search tree)를 사용하여 데이터를 저장하고, 저장된
데이터가 항상 정렬된 상태를 유지합니다. 데이터의 정렬이 필요한 경우에는 TreeSet을 사용할 수 있습니다. 한마디로, 데이터의 정렬과 Set의 특징인 중복 값 방지라는 특징을 동시에 갖는 자료구조입니다. 하지만,
TreeSet은 데이터의 추가, 삭제, 검색에 조금 더 많은 시간이 소요될 수 있습니다.

## Set 자료구조 선택 시 고려 사항

각 자료 구조는 데이터의 특성과 처리의 요구 사항에 따라 선택되어야 합니다. HashSet, LinkedHashSet, TreeSet은 모두 중복된 값을 허용하지 않고 고유한 값을 저장하고자 할 때 사용되며, 각각의
특징과 장단점을 고려하여 선택해야 합니다.

- HashSet은 데이터를 해시 함수를 사용하여 저장하므로, 데이터의 추가, 삭제, 검색이 빠르게 처리되어야 하는 경우에 사용됩니다. 데이터의 순서가 중요하지 않고, 높은 성능이 요구되는 경우에 적합합니다.
- LinkedHashSet은 데이터의 추가 순서를 보존하는 특징이 있어, 데이터의 순서가 중요한 경우에 사용됩니다. 데이터를 추가한 순서대로 데이터를 저장하고자 할 때, 또는 데이터의 순서에 따른 처리가 필요한
  경우에 적합합니다.
- TreeSet은 데이터를 정렬된 상태로 저장하고자 할 때 사용됩니다. 이진 검색 트리를 사용하여 데이터를 저장하기 때문에, 항상 정렬된 상태를 유지하게 됩니다. 데이터의 정렬이 필요한 경우에 적합합니다.

*****

## 해시가 무엇인가요?

Hash는 ***임의의 길이를 갖는 데이터를 일정한 길이의 데이터로 변환하는 것***을 뜻합니다. 그리고, 이와 같은 기능(임의의 길이를 갖는 데이터를 일정한 길이의 데이터로 변환하는 기능)을 하는 함수를 해시
함수(Hash Function)라고 합니다.

예를 들어, 임의의 길이를 갖는 데이터를 32bit 길이로 반환하는 해시 함수는 아래와 같이 동작합니다. 무엇을 넣든 출력은 32bit가 됩니다.

![hash_function](https://user-images.githubusercontent.com/50406129/230704055-72bcfb51-b794-4c5c-897c-61a679da4ef5.png)

해시 함수에 데이터를 넣고 결과를 받는, 전 과정을 해싱(hashing)이라고 하며, 해시 함수에 의해 얻어진 결괏값을 다이제스트(digest)라고 합니다. HashSet이나 HashTable 등 Hash가 들어간
대부분의 자료구조에서는 이렇게 얻어낸 다이제스트를 그들이 가진 내부 배열의 인덱스로 사용합니다.

왜 그럴까요? 무엇이 이득이길래 다이제스트를 인덱스로 사용하는 걸까요?

다이제스트를 인덱스로 사용하면 값에 대한 접근이 O(1) 시간에 이루어집니다. 이것이 다이제스트를 인덱스로 사용하는 이유입니다. ArrayList와 비교해보면서 다이제스트를 인덱스로 사용하는 것의 장점에 대해
알아봅시다.

ArrayList는 특정 값이 있는지 없는지를 알아내기 위해서 값을 저장하고 있는 배열을 처음부터 순차적으로 조회하며 값을 비교해야 합니다. 예를 들어 ArrayList에서 '어떤 값'이 존재하는지 확인하는
contains() 함수는 아래와 같습니다.

```java
class ArrayList {
    // ...
    public boolean contains(Object o) {
        for (int i = 0; i < size; i++) {
            if (o.equals(es[i])) {
                return true;
            }
        }
        return false;
    }
    // ...
}
```

찾고자 하는 '어떤 값'이 있는지 없는지 확인하기 위해 배열의 모든 요소를 방문하는 것을 확인할 수 있습니다.

반면, 다이제스트를 인덱스로 사용하면 그럴 필요가 없습니다. '어떤 값'을 해시 함수에 넣어 다이제스트를 얻고 해당 인덱스에 값이 존재하는지, 존재하는 값이 해당 값과 같은지만 확인하면 되므로 배열을 순회할 필요가
없습니다. 단번에 접근이 가능한 것입니다. 이와 같은 구조의 contains() 함수는 아래와 같습니다.

```java
class HashDataStructure {
    // ...
    public boolean contains(Object o) {
        int digest = hashFunction(o);
        return o.equals(es[digest]);
    }

    public int hashFunction(Object o) {
        // ... 임의의 길이를 갖는 데이터를 일정한 길이의 데이터로 변환하는 계산 ...
    }
    // ...
}
```

정리하자면 해시를 사용하지 않으면 특정 값을 찾을 때 아무런 힌트가 없으므로 모든 요소를 방문해야 하지만, 해시를 사용하면 다이제스트라는 힌트가 생기므로 해당 힌트를 사용하여 단번에 요소에 접근할 수 있다는 장점이
있습니다.

### 해시 충돌

해시를 배울 때 함께 배우는 것이 바로 해시 충돌입니다. 해시는 임의의 길이를 갖는 데이터를 ***일정한 길이***의 데이터로 변환하므로, 필연적으로 다이제스트가 겹칠 수밖에 없습니다.

간단하게 생각해봅시다. 32bit는 너무 크니까 일정한 길이를 2bit라고 가정하겠습니다. 2bit로는 총 4개의 수를 표현할 수 있습니다.

- 00
- 01
- 10
- 11

다이제스트의 길이를 2bit로 정하면 나올 수 있는 다이제스트는 위와 같이 총 4가지입니다. 그에 반해, 들어오는 데이터는 몇 개든 들어올 수 있습니다. 여기서 문제가 발생합니다.

- 1개의 데이터를 해시 함수에 넣으면 해당 다이제스트는 다른 무엇과도 겹치지 않겠지만,
- 5개의 데이터를 해시 함수에 넣으면 최소 하나 이상의 다이제스트가 반드시 겹칩니다.
  (비유하자면 방이 4개인데 사람이 5명인 경우 반드시 누군가는 방을 같이 써야 하는 것과 동일합니다)

이러한 서로 다른 데이터의 다이제스트가 겹치는 경우를 해시 충돌이라고 합니다.

이게 왜 문제일까요?

우리는 앞서 다이제스트를 인덱스로 사용한다고 배웠습니다. 실생활에서는 한 방에 두 명이 자든 세 명이 자든 상관이 없지만, 컴퓨터는 다릅니다. 배열의 요소에 담긴 값이 'a'이면서 동시에 'b'일 수는 없습니다.

### 충돌 해결(Collision resolution)

해시 충돌이 발생하였을 때 배열의 요소에 두 값을 동시에 담을 수 없으니 무언가 해결 방법이 있어야 합니다. 이럴 때 사용되는 방법은 크게 두 가지로 나뉩니다. 사진으로 보면 이해가 쉬우니 사진을 먼저
보여드리겠습니다.

![collision_resolution](https://user-images.githubusercontent.com/50406129/230707977-2ce295c1-fe3c-4ec0-8917-41639c56dd31.png)

#### Open Addressing

Open Addressing은 해시 충돌이 발생할 경우 빈 곳을 찾아가서 채우는 방식입니다.

- 장점
    - 충돌이 발생하더라도 해당 버킷에 데이터를 저장하므로 추가적인 메모리가 필요하지 않습니다.
    - 데이터가 연속적으로 저장되어 있으므로 CPU 캐시 효율이 높아집니다.
    - 데이터를 직접 저장하므로 포인터를 따라가는 과정이 필요 없습니다.
- 단점
    - 일정 범위에 값이 몰려있는 경우 계속 충돌이 발생하고 검색 성능이 저하될 수 있습니다. (클러스터링 문제)
    - 삭제된 데이터를 처리하기 위해 빈 버킷을 표시하는 등의 별도의 처리가 필요합니다.

#### Separate Chaining

애초에, 배열에 들어가는 값을 노드로 감쌉니다. 만약 충돌이 발생하면, 충돌이 발생한 지점에 있는 노드의 nextNode를 본인으로 설정합니다.

- 장점
    - 충돌이 발생하면 그냥 연결 노드로 이으면 되니 충돌 처리가 간단합니다.
    - 각 버킷에 독립적으로 데이터를 저장하므로 클러스터링 문제가 발생하지 않습니다.
- 단점
    - 버킷의 요소마다 연결 리스트를 유지해야 하므로 메모리 사용량이 증가할 수 있습니다.
    - 연결 리스트로 인해 CPU 캐시 효율이 낮아질 수 있습니다.
    - 값을 찾을 때 연결 리스트를 탐색해야 하므로 검색 성능이 Open Addressing에 비해 낮을 수 있습니다.

자바 11은 충돌을 처리하는 방법으로 Separate Chaining을 사용합니다. 우리도 Separate Chaining을 사용하여 HashSet과 LinkedHashSet을 구현할 것입니다.

> 부하율(Load factor)이라는 개념도 있습니다. 부하율이란 버킷에 저장된 데이터의 수와 버킷의 크기를 비율로 나타내는 말입니다.
> 간단하게 말해서 버킷이 차 있는 비율을 말합니다. 0%면 텅텅 빈 거고 100%면 꽉 차 있는 것입니다.
>
> 부하율이 낮을 때에는 충돌이 발생하더라도 바로 다음 칸에 저장하면 되니까 Open Addressing 방식에서 큰 문제가 발생하지 않습니다.
> 하지만 부하율이 높은 경우에는 충돌이 발생했을 때 다음 칸도 채워져 있을 가능성이 높으므로 빈칸을 찾는 시간이 매우 오래 걸리게 되어 Open Addressing 방식의 효율이 급격히 낮아집니다.
>
> 보통 데이터가 0.7~0.8(70% ~ 80%) 정도 채워질 경우 이러한 급격한 성능 저하가 발생한다고 합니다.
> 그래서 Java 11에서도 DEFAULT_LOAD_FACTOR 값을 0.75로 두어 버킷의 부하율이 0.75 이상이 되면 버킷의 크기를 늘리는 방식을 사용합니다.
